// Copyright Yarn Spinner Pty Ltd
// Licensed under the MIT License. See LICENSE.md in project root for license information.

namespace Yarn.Compiler
{
    using Antlr4.Runtime;
    using Antlr4.Runtime.Misc;
    using Antlr4.Runtime.Tree;
    using System;
    using System.Collections.Generic;
    using System.Text;

    /// <summary>
    /// A Visitor that walks an expression parse tree and generates string
    /// table entries, which are provided to a <see
    /// cref="StringTableManager"/>. This string table can then be provided
    /// to future compilation passes, or stored for later use. Call the
    /// <see cref="AbstractParseTreeVisitor{Result}.Visit(Antlr4.Runtime.Tree.IParseTree)"/> method to begin generating string table
    /// entries.
    /// </summary>
    internal class StringTableGeneratorVisitor : YarnSpinnerParserBaseVisitor<int>
    {
        private readonly List<Diagnostic> diagnostics = new List<Diagnostic>();

        private YarnSpinnerParser.NodeContext? currentNodeContext;
        private string? currentNodeName;
        private readonly string fileName;
        private readonly StringTableManager stringTableManager;

        /// <summary>
        /// Gets the collection of <see cref="Diagnostic"/> objects
        /// generated by this object.
        /// </summary>
        public IEnumerable<Diagnostic> Diagnostics => this.diagnostics;

        public StringTableGeneratorVisitor(string fileName, StringTableManager stringTableManager)
        {
            this.fileName = fileName;
            this.stringTableManager = stringTableManager;
        }

        public override int VisitNode(YarnSpinnerParser.NodeContext context)
        {
            currentNodeContext = context;
            currentNodeName = context.NodeTitle ?? "<unknown>";

            // This is a regular node
            // this.Visit(context.body());

            var body = context.body();
            if (body != null)
            {
                this.Visit(body);
            }
            // String table generator: don't crash if a node has no body


            return 0;
        }

        public override int VisitLine_statement([NotNull] YarnSpinnerParser.Line_statementContext context)
        {
            int lineNumber = context.Start.Line;

            YarnSpinnerParser.HashtagContext[] hashtags = context.hashtag();
            var lineIDTag = Compiler.GetContentIDTag(ContentIdentifierType.Line, hashtags);
            var lineID = lineIDTag?.text.Text ?? null;

            var hashtagTexts = new List<string>(GetHashtagTexts(hashtags));

            if (context.IsLastLineBeforeOptions)
            {
                hashtagTexts.Add("lastline");
            }

            var hashtagText = hashtagTexts.ToArray();

            string? composedString;

            GenerateFormattedText(
                context.line_formatted_text().children,
                out composedString,
                out var _);

            // Does this string table already have a string with this ID?
            if (lineID != null && stringTableManager.ContainsKey(lineID))
            {
                // If so, this is an error.
                ParserRuleContext diagnosticContext;

                diagnosticContext = lineIDTag ?? (ParserRuleContext)context;

                this.diagnostics.Add(new Diagnostic(fileName, diagnosticContext, $"Duplicate line ID {lineID}"));

                return 0;
            }


            // If the line has a '#shadow:' ID, record that fact.
            var shadowTag = Compiler.GetContentIDTag(ContentIdentifierType.Shadow, hashtags);
            if (shadowTag != null)
            {
                context.ShadowLineID = "line:" + shadowTag.text.Text.Substring("shadow:".Length);
            }

            // It's illegal for a shadow line to have an explicit line ID.
            if (shadowTag != null && lineIDTag != null)
            {
                var message = "Lines cannot have both a '#line' tag and a '#shadow' tag.";

                this.diagnostics.Add(new Diagnostic(
                    fileName, shadowTag, message));

                this.diagnostics.Add(new Diagnostic(
                    fileName, lineIDTag, message));
            }

            lineID = stringTableManager.RegisterString(
                context,
                composedString?.ToString(),
                fileName,
                currentNodeName ?? "<unknown node>",
                lineID,
                lineNumber,
                hashtagText,
                context.ShadowLineID
                );

            context.LineID = lineID;

            context.LineIDIsImplicit = lineIDTag == null;

            return 0;
        }

        internal static string[] GetHashtagTexts(YarnSpinnerParser.HashtagContext[] hashtags)
        {
            // Add hashtag
            var hashtagText = new List<string>();
            foreach (var tag in hashtags)
            {
                hashtagText.Add(tag.text.Text);
            }

            return hashtagText.ToArray();
        }

        private void GenerateFormattedText(IList<IParseTree> nodes, out string outputString, out int expressionCount)
        {
            expressionCount = 0;
            StringBuilder composedString = new StringBuilder();

            // First, visit all of the nodes, which are either terminal
            // text nodes or expressions. if they're expressions, we
            // evaluate them, and inject a positional reference into the
            // final string.
            foreach (var child in nodes)
            {
                if (child is ITerminalNode)
                {
                    composedString.Append(child.GetText());
                }
                else if (child is ParserRuleContext)
                {
                    // Expressions in the final string are denoted as the
                    // index of the expression, surrounded by braces { }.
                    // However, we don't need to write the braces here
                    // ourselves, because the text itself that the parser
                    // captured already has them. So, we just need to write
                    // the expression count.
                    composedString.Append(expressionCount);
                    expressionCount += 1;
                }
            }

            outputString = composedString.ToString().Trim();
        }
    }

    public partial class YarnSpinnerParser
    {
        public partial class Line_statementContext
        {
            /// <summary>
            /// Gets or sets the localised line ID associated with this line
            /// statement.
            /// </summary>
            public string? LineID { get; set; }

            /// <summary>
            /// Gets or sets a value indiciating whether the line ID was added
            /// implicitly.
            /// </summary>
            public bool LineIDIsImplicit { get; set; } = false;

            /// <summary>
            /// Gets or sets the shadow line ID associated with this line
            /// statement.
            /// </summary>
            public string? ShadowLineID { get; set; }

            /// <summary>
            /// Gets or sets a value indicating whether this line is the last
            /// one before a group of options.
            /// </summary>
            public bool IsLastLineBeforeOptions { get; internal set; }
        }
    }
}

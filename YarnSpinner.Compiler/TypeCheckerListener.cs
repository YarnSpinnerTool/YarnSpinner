// Uncomment to ensure that all expressions have a known type at compile time
// #define VALIDATE_ALL_EXPRESSIONS

namespace Yarn.Compiler
{
    using Antlr4.Runtime;
    using Antlr4.Runtime.Misc;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading;
    using TypeChecker;
    using Yarn.Utility;

    internal abstract class InterruptableListener : YarnSpinnerParserBaseListener
    {
        protected CancellationToken CancellationToken { get; private set; }
        protected InterruptableListener(CancellationToken cancellationToken)
        {
            this.CancellationToken = cancellationToken;
        }
    }

    /// <summary>
    /// <see cref="TypeCheckerListener"/> creates type constraints (subclasses
    /// of <see cref="TypeConstraint"/>) for expressions and values found in a
    /// parse tree, as well as type declarations that it encounters. These
    /// constraints can then be resolved by a <see cref="Solver"/> to determine
    /// the types of expressions and values in the source code (or to determine
    /// if there was a type error.)
    /// </summary>
    internal class TypeCheckerListener : InterruptableListener
    {
        /// <summary>
        /// Stores the total number of type variables that have been produced.
        /// </summary>
        /// <remarks>
        /// This variable is used to ensure that names for new type variables
        /// are always unique.
        /// </remarks>
        private static int typeParameterCount = 0;

        /// <summary>
        /// The token stream used to produce the current file.
        /// </summary>
        /// <remarks>
        /// This variable is used to get documentation comments via calls to
        /// <see cref="Compiler.GetDocumentComments"/>.
        /// </remarks>
        private readonly CommonTokenStream tokens;

        /// <summary>
        /// The name of the source file that we are currently walking.
        /// </summary>
        /// <remarks>
        /// This variable is used to help produce error messages.
        /// </remarks>
        private readonly string sourceFileName = "<not set>";

        /// <summary>
        /// The list of all known <see cref="Declaration"/> objects.
        /// </summary>
        /// <remarks>
        /// This list is passed to the constructor, and added to while walking
        /// the parse tree when new explicit or implicit variable declarations
        /// need to be added.
        /// </remarks>
        private readonly List<Declaration> knownDeclarations;

        /// <summary>
        /// Contains the list of all named type declarations found so far, from
        /// both built-in types (string, number, etc) and user-defined types
        /// (enums). This doesn't include function types.
        /// </summary>
        private readonly List<TypeBase> knownTypes;

        /// <summary>
        /// The current type solution produced by running this listener on a
        /// parse tree.
        /// </summary>
        public Substitution TypeSolution { get => typeSolution; private set => typeSolution = value; }

        private List<TypeConstraint> typeEquations = new List<TypeConstraint>();

        private readonly List<Diagnostic> diagnostics = new List<Diagnostic>();

        /// <summary>
        /// The name of the node that we are currently walking.
        /// </summary>
        /// <remarks>
        /// This variable is used to help produce error messages.
        /// </remarks>
        private string? currentNodeName = null;

        /// <summary>
        /// The current incremental type solution.
        /// </summary>
        private Substitution typeSolution;
        private readonly HashSet<TypeConstraint> failingTypeConstraints;

        /// <summary>
        /// Gets the list of diagnostics produced during type checking.
        /// </summary>
        public IEnumerable<Diagnostic> Diagnostics => this.diagnostics;

        /// <summary>
        /// Gets the list of type equations that have been generated by this
        /// listener.
        /// </summary>
        internal List<TypeConstraint> TypeEquations { get => this.typeEquations; }

        /// <summary>
        /// Gets the collection of file-level hashtags that were found as a
        /// result of using this <see cref="TypeCheckerListener"/> to visit a
        /// <see cref="ParserRuleContext"/>.
        /// </summary>
        public ICollection<string> FileTags { get; } = new List<string>();

        /// <summary>Maps the names of types as they appear in the language
        /// (string, bool, number) to actual type objects.</summary>
        // TODO: maybe the 'real' type names should be lowercased too? Rather
        // than relying on this kind of mapping?
        private static readonly Dictionary<string, IType> LanguageTypeNames = new Dictionary<string, IType> {
            { "string", Types.String },
            { "number", Types.Number },
            { "bool", Types.Boolean },
        };

        /// <summary>
        /// Initializes a new instance of the <see cref="TypeCheckerListener"/>
        /// class.
        /// </summary>
        /// <param name="sourceFileName">The name of the source file being
        /// walked.</param>
        /// <param name="tokens">The token stream produced from the source
        /// file.</param>
        /// <param name="knownDeclarations">The list of all known variable and
        /// function declarations. This list will be added to while walking the
        /// parse tree.</param>
        /// <param name="knownTypes">The list of all known types. This list will
        /// be added to while walking the parse tree.</param>
        /// <param name="typeSolution">An existing type solution to build
        /// upon.</param>
        /// <param name="failingTypeConstraints">A collection of <see
        /// cref="TypeConstraint"/> objects. During type checking, this
        /// collection will be added to if a type constraint fails to resolve by
        /// the end of a file.</param>
        /// <param name="cancellationToken">A token used to indicate that type
        /// checking should be cancelled.</param>
        public TypeCheckerListener(string sourceFileName, CommonTokenStream tokens, List<Declaration> knownDeclarations, List<TypeBase> knownTypes, Substitution typeSolution, HashSet<TypeConstraint> failingTypeConstraints, CancellationToken cancellationToken) : base(cancellationToken)
        {
            this.sourceFileName = sourceFileName;
            this.tokens = tokens;
            this.knownDeclarations = knownDeclarations;
            this.knownTypes = knownTypes;
            this.typeSolution = typeSolution;
            this.failingTypeConstraints = failingTypeConstraints;

            // Cache our declarations in our lookup table, to accelerate later
            // queries
            foreach (var decls in knownDeclarations)
            {
                try
                {
                    this.declarationLookup.Add(decls.Name, decls);
                }
                catch (ArgumentException)
                {
                    // Duplicate name; error diagnostics will be emitted
                    // earlier, so ignore this here
                }
            }
        }

        /// <summary>
        /// Gets a declaration for the identifier named <paramref name="name"/>,
        /// or <see langword="null"/>.
        /// </summary>
        /// <param name="name">The name of the identifier to get a declaration
        /// for.</param>
        /// <returns>A <see cref="Declaration"/> object for <paramref
        /// name="name"/>, or <see langword="null"/> if none was
        /// found.</returns>
        private Declaration? GetKnownDeclaration(string? name)
        {
            if (name == null) { return null; }
            if (declarationLookup.TryGetValue(name, out var result))
            {
                return result;
            }
            else
            {
                return null;
            }
        }

        private void AddDeclaration(Declaration declaration)
        {
            knownDeclarations.Add(declaration);
            try
            {

                declarationLookup.Add(declaration.Name, declaration);
            }
            catch (ArgumentException)
            {
                // Declaration with this name already exists; this is already an
                // error elsewhere, so drop this
            }
        }

        private void RemoveDeclaration(Declaration declaration)
        {
            knownDeclarations.Remove(declaration);
            declarationLookup.Remove(declaration.Name);
        }

        private readonly Dictionary<string, Declaration> declarationLookup = new Dictionary<string, Declaration>();

        private void AddDiagnostic(ParserRuleContext context, string message, Diagnostic.DiagnosticSeverity severity = Diagnostic.DiagnosticSeverity.Error)
        {
            this.diagnostics.Add(new Diagnostic(this.sourceFileName, context, message, severity));
        }

        private TypeEqualityConstraint AddEqualityConstraint(IType a, IType b, ParserRuleContext context, FailureMessageProvider failureMessageProvider)
        {
            TypeEqualityConstraint item = new TypeEqualityConstraint(a, b)
            {
                SourceContext = context,
                SourceFileName = this.sourceFileName,
                SourceRange = Utility.GetRange(context),
                FailureMessageProvider = failureMessageProvider,
                SourceExpression = context.GetTextWithWhitespace()
            };

            this.TypeEquations.Add(item);
            return item;
        }

        private TypeConstraint AddDisjunctionOfEqualitiesConstraint(IType a, IEnumerable<IType> b, ParserRuleContext context, FailureMessageProvider failureMessageProvider)
        {
            if (b.Count() == 0)
            {
                // We didn't get any types that 'a' must be equal to, and that's
                // a problem. Produce a constraint saying that 'a' is an error.
                return AddEqualityConstraint(a, Types.Error, context, failureMessageProvider);
            }
            else if (b.Count() == 1)
            {
                // We got a single type to constrain against. Don't bother
                // creating a disjunction with only a single constraint - just
                // the constraint will do.
                return AddEqualityConstraint(a, b.Single(), context, failureMessageProvider);
            }

            var disjunction = new DisjunctionConstraint(
                b.Select(other =>
                {
                    return new TypeEqualityConstraint(a, other)
                    {
                        SourceContext = context,
                        SourceExpression = context.GetTextWithWhitespace(),
                        SourceFileName = this.sourceFileName,
                        SourceRange = Utility.GetRange(context),
                        FailureMessageProvider = failureMessageProvider,
                    };
                })
            )
            {
                SourceContext = context,
                SourceExpression = context.GetTextWithWhitespace(),
                SourceFileName = this.sourceFileName,
                SourceRange = Utility.GetRange(context),
                FailureMessageProvider = failureMessageProvider,
            };

            this.TypeEquations.Add(disjunction);
            return disjunction;
        }

        private TypeConvertibleConstraint AddConvertibleConstraint(IType from, IType to, ParserRuleContext context, FailureMessageProvider failureMessageProvider)
        {
            TypeConvertibleConstraint item = new TypeConvertibleConstraint(from, to);
            item.SourceFileName = this.sourceFileName;
            item.SourceContext = context;
            item.SourceRange = Utility.GetRange(context);
            item.FailureMessageProvider = failureMessageProvider;
            item.SourceExpression = context.GetTextWithWhitespace();

            this.TypeEquations.Add(item);
            return item;
        }

        private void AddHasEnumMemberConstraint(IType type, string memberName, ParserRuleContext context, FailureMessageProvider failureMessageProvider)
        {
            TypeHasMemberConstraint item = new TypeHasMemberConstraint(type, memberName);
            item.SourceContext = context;
            item.SourceFileName = this.sourceFileName;
            item.SourceRange = Utility.GetRange(context);
            item.FailureMessageProvider = failureMessageProvider;
            item.SourceExpression = context.GetTextWithWhitespace();

            this.TypeEquations.Add(item);
        }

        private void AddHasNameConstraint(IType type, string name, ParserRuleContext context, FailureMessageProvider failureMessageProvider)
        {
            TypeHasNameConstraint item = new TypeHasNameConstraint(type, name);
            item.SourceContext = context;
            item.SourceFileName = this.sourceFileName;
            item.SourceRange = Utility.GetRange(context);
            item.FailureMessageProvider = failureMessageProvider;
            item.SourceExpression = context.GetTextWithWhitespace();

            this.TypeEquations.Add(item);
        }

        private TypeVariable GenerateTypeVariable(string? name, ParserRuleContext context)
        {
            string variableName;
            if (name != null)
            {
                variableName = "T(" + name + ")";
            }
            else
            {
                variableName = "T" + typeParameterCount++;
            }

            return new TypeVariable(variableName, context);
        }

        /// <summary>
        /// Adds a file hashtag to the parse result.
        /// </summary>
        /// <param name="context">The file hashtag parse node.</param>
        public override void ExitFile_hashtag([NotNull] YarnSpinnerParser.File_hashtagContext context)
        {
            this.FileTags.Add(context.text.Text);
        }
        public override void ExitTitle_header([NotNull] YarnSpinnerParser.Title_headerContext context)
        {
            // We don't do any type checking here, but we do store the name of
            // the current node we're in for diagnostic purposes.
            this.currentNodeName = context.title?.Text;
        }

        public override void ExitDeclare_statement([NotNull] YarnSpinnerParser.Declare_statementContext context)
        {
            YarnSpinnerParser.VariableContext variableContext = context.variable();
            var name = variableContext?.VAR_ID()?.GetText();
            Declaration? declaration = this.GetKnownDeclaration(name);

            // Do we already have a explicit declaration for a variable with
            // this name? It's an error if we do.
            if (declaration != null && declaration.IsImplicit == false)
            {
                this.AddDiagnostic(context, $"Redeclaration of existing variable {name}");
                return;
            }

            // Figure out the type of the declaration; we'll determine its
            // initial value later
            var constantValueVisitor = new LiteralValueVisitor(context, sourceFileName, this.diagnostics);

            var typeIdentifier = this.GenerateTypeVariable(name + " declaration", context);

            // The type of this identifier is equal to the type of its default
            // value.
            if (context.expression() == null)
            {
                // No expression present, due to a syntax error. We can't do any
                // type checking on this.
                return;
            }

            this.AddEqualityConstraint(typeIdentifier, context.expression().Type, context, s => $"The type of {name}'s initial value \"{context.expression().GetText()}\" ({context.expression().Type.Substitute(s)}) doesn't match the type of the variable {typeIdentifier.Substitute(s)}.");

            if (context.type != null)
            {
                // We were given an explicit type name. Add the further
                // constraint that whatever type we have has this name.
                string typeName = context.type.Text;

                if (LanguageTypeNames.TryGetValue(typeName, out var type))
                {
                    // Constrain the type of this variable to the named type.
                    this.AddEqualityConstraint(typeIdentifier, type, context, s => $"{name}'s type ({typeIdentifier.Substitute(s)}) must be {type.Substitute(s)}");
                }
                else
                {
                    // We don't have a built-in mapping of this name to a type.
                    // Add a constraint such that, whatever the type this
                    // variable is, the type's name is equal to what's specified
                    // here.
                    this.AddHasNameConstraint(typeIdentifier, typeName, context, s => $"{name}'s type must be {typeName}");
                }
            }

            string? description = Compiler.GetDocumentComments(this.tokens, context);

            if (declaration != null && declaration.IsImplicit)
            {
                // We're replacing an implicit declaration with an explicit one.
                // Before we replace it, we need to make sure that the type
                // variable (which other constraints might rely on!) is
                // connected to the type of the new declaration.
                this.AddEqualityConstraint(declaration.Type, typeIdentifier, context, s => $"{name} was declared to be a {typeIdentifier.Substitute(s)}, but it was used elsewhere as a {declaration.Type.Substitute(s)}");

                // Remove the implicit declaration from the known declarations
                // in preparation for adding the new one.
                this.RemoveDeclaration(declaration);
            }

            declaration = new Declaration
            {
                Name = name ?? "<unknown>",
                Type = typeIdentifier,
                Description = description,
                DefaultValue = null,
                SourceFileName = this.sourceFileName,
                SourceNodeName = this.currentNodeName,
                Range = variableContext != null ? Utility.GetRange(variableContext) : Range.InvalidRange,
                IsImplicit = false,
                IsInlineExpansion = false,
                InitialValueParserContext = context.expression(),
            };

            this.AddDeclaration(declaration);
        }

        public override void ExitValueTrue([NotNull] YarnSpinnerParser.ValueTrueContext context)
        {
            context.Type = Types.Boolean;
        }

        public override void ExitValueFalse([NotNull] YarnSpinnerParser.ValueFalseContext context)
        {
            context.Type = Types.Boolean;
        }

        public override void ExitValueNumber([NotNull] YarnSpinnerParser.ValueNumberContext context)
        {
            context.Type = Types.Number;
        }

        public override void ExitValueString([NotNull] YarnSpinnerParser.ValueStringContext context)
        {
            context.Type = Types.String;
        }

        public override void ExitValueVar([NotNull] YarnSpinnerParser.ValueVarContext context)
        {
            context.Type = context.variable().Type;
        }

        public override void ExitValueTypeMemberReference([NotNull] YarnSpinnerParser.ValueTypeMemberReferenceContext context)
        {
            var typeName = context.typeMemberReference()?.typeName?.Text ?? null;
            var memberName = context.typeMemberReference()?.memberName?.Text ?? null;

            // If we don't have a type member reference parse node, or if we
            // don't have a member name, then that's an error.
            if (context.typeMemberReference() == null || memberName == null)
            {
                context.Type = Types.Error;
                return;
            }

            // Attempt to find a type that we already know about, by matching
            // the type name (if provided) and matching the member name. We can
            // only use the result if precisely one type matches; otherwise,
            // we'll need to resolve the type via constraints.
            var matchingTypes = this.knownTypes.Where(t =>
                // A name was provided, and the type matches the name
                (typeName == null || t.Name == typeName)
                // The type's members include the provided member name
                && t.TypeMembers.Keys.Contains(memberName)
            );

            if (matchingTypes.Count() == 1)
            {
                // Precisely 1 type matches what was specified. The type of this
                // expression must be this.
                context.Type = matchingTypes.Single();
                return;
            }

            // Otherwise, the type of this expression needs to be resolved via
            // constraints.

            context.Type = this.GenerateTypeVariable(null, context);

            if (typeName != null)
            {
                // Constrain to a type named typeName, containing a member named
                // memberName
                this.AddHasNameConstraint(context.Type, typeName, context.typeMemberReference(), s => $"No type called {typeName} could be found");

                this.AddHasEnumMemberConstraint(context.Type, memberName, context.typeMemberReference(), s => $"{typeName} does not have a member named {memberName}");
            }
            else
            {
                // We don't have a type name, so we can only constrain based on
                // the member name.
                this.AddHasEnumMemberConstraint(context.Type, memberName, context.typeMemberReference(), s =>
                {
                    if (context.Type.Substitute(s) is TypeBase resolvedType)
                    {
                        // The type of the context was resolved, and it doesn't have this member.
                        return $"Type {resolvedType} does not have a member named {memberName}";
                    }
                    else
                    {
                        // The type of the context couldn't be resolved.
                        return $"No type containing a member named {memberName} could be found";
                    }
                });
            }
        }

        public override void ExitVariable([NotNull] YarnSpinnerParser.VariableContext context)
        {
            var variableID = context.VAR_ID();

            if (variableID == null)
            {
                // This is a parse error, so the type of this node is the error
                // type.
                context.Type = Types.Error;
                return;
            }

            string name = variableID.GetText();
            var declaration = this.GetKnownDeclaration(name);

            if (declaration == null)
            {
                var typeVariable = this.GenerateTypeVariable(name, context);
                declaration = new Declaration
                {
                    Name = name,
                    Type = typeVariable,
                    Description = $"Implicitly declared in {this.sourceFileName}, node {this.currentNodeName}",
                    Range = Utility.GetRange(context),
                    IsImplicit = true,
                    IsInlineExpansion = false,
                    SourceFileName = this.sourceFileName,
                    SourceNodeName = this.currentNodeName,
                };
                this.AddDeclaration(declaration);
            }

            context.Type = declaration.Type;
        }

        public override void ExitExpParens([NotNull] YarnSpinnerParser.ExpParensContext context)
        {
            // The type of a parentheses expression is equal to the type of its
            // child.
            context.Type = context.expression()?.Type ?? Types.Error;
        }

        public override void ExitExpAddSub([NotNull] YarnSpinnerParser.ExpAddSubContext context)
        {
            var type = this.GenerateTypeVariable(null, context);
            context.Type = type;

            IType operandAType = context.expression(0)?.Type ?? Types.Error;
            IType operandBType = context.expression(1)?.Type ?? Types.Error;

            IEnumerable<IType> permittedTypes;

            string op = context.op.Text;

            switch (op)
            {
                case "+":
                    permittedTypes = new[] { Types.Number, Types.String };
                    break;
                case "-":
                    permittedTypes = new[] { Types.Number };
                    break;
                default:
                    throw new InvalidOperationException($"Internal error: {typeof(YarnSpinnerParser.ExpAddSubContext)} had invalid op \"{op}\"");
            }

            this.AddDisjunctionOfEqualitiesConstraint(type, permittedTypes, context, s => $"Operation '{op}' can't be used with a value of type {operandAType.Substitute(s)}");

            this.AddEqualityConstraint(type, operandAType, context, s => $"Operation '{op}' can't be used with a value of type {operandAType.Substitute(s)}");
            this.AddEqualityConstraint(operandAType, operandBType, context, s => $"Operation '{op}'s values must both be the same type, not {operandAType.Substitute(s)} and {operandBType.Substitute(s)}");
        }

        public override void ExitExpMultDivMod([NotNull] YarnSpinnerParser.ExpMultDivModContext context)
        {
            var type = this.GenerateTypeVariable(null, context);
            context.Type = type;

            IType operandAType = context.expression(0)?.Type ?? Types.Error;
            IType operandBType = context.expression(1)?.Type ?? Types.Error;

            string op = context.op.Text;

            this.AddEqualityConstraint(type, Types.Number, context, s => $"Operation '{op}' can only be used with {Types.Number}");

            this.AddEqualityConstraint(type, operandAType, context, s => $"Operation '{op}' can't be used with a value of type {operandAType.Substitute(s)}");
            this.AddEqualityConstraint(operandAType, operandBType, context, s => $"Operation '{op}'s values must both be the same type, not {operandAType.Substitute(s)} and {operandBType.Substitute(s)}");
        }

        public override void ExitExpComparison([NotNull] YarnSpinnerParser.ExpComparisonContext context)
        {
            // The result of a comparison is boolean; the types of the
            // expressions must be identical.
            context.Type = Types.Boolean;

            IType operandAType = context.expression(0)?.Type ?? Types.Error;
            IType operandBType = context.expression(1)?.Type ?? Types.Error;

            string op = context.op.Text;

            this.AddEqualityConstraint(operandAType, operandBType, context, s => $"Operation '{op}'s values must both be the same type, not {operandAType.Substitute(s)} and {operandBType.Substitute(s)}");
        }

        public override void ExitExpEquality([NotNull] YarnSpinnerParser.ExpEqualityContext context)
        {
            // The result of an equality is boolean; the types of the
            // expressions must be identical.
            context.Type = Types.Boolean;

            IType operandAType = context.expression(0)?.Type ?? Types.Error;
            IType operandBType = context.expression(1)?.Type ?? Types.Error;

            string op = context.op.Text;

            this.AddEqualityConstraint(operandAType, operandBType, context, s => $"Operation '{op}'s values must both be the same type, not {operandAType.Substitute(s)} and {operandBType.Substitute(s)}");
        }

        public override void ExitExpAndOrXor([NotNull] YarnSpinnerParser.ExpAndOrXorContext context)
        {
            // The result of a logical and, or, or xor is boolean; the types of
            // the expressions must also be boolean.
            var type0 = context.expression(0)?.Type;
            var type1 = context.expression(1)?.Type;
            if (type0 == null || type1 == null)
            {
                context.Type = Types.Error;
                return;
            }

            context.Type = Types.Boolean;

            this.AddEqualityConstraint(type0, Types.Boolean, context, s => $"{context.op.Text} operands must be {Types.Boolean}, not {type0.Substitute(s)}");
            this.AddEqualityConstraint(type0, type1, context, s => $"{context.op.Text} operands must be the same type, not {type0} and {type1}");
        }

        public override void ExitExpNot([NotNull] YarnSpinnerParser.ExpNotContext context)
        {
            // The result of a logical not is boolean; the type of the operand
            // must also be boolean.
            context.Type = Types.Boolean;

            IType type = context.expression()?.Type ?? Types.Error;

            this.AddEqualityConstraint(type, Types.Boolean, context, s => $"{context.op.Text} operand must be {Types.Boolean}, not {type.Substitute(s)}");
        }

        public override void ExitExpNegative([NotNull] YarnSpinnerParser.ExpNegativeContext context)
        {
            // The result of a negation is a number; the type of the operand
            // must also be a number.
            context.Type = Types.Number;
            IType type = context.expression()?.Type ?? Types.Error;
            this.AddEqualityConstraint(type, Types.Number, context, s => $"{context.op.Text} operand must be {Types.Number}, not {type.Substitute(s)}");
        }

        public override void ExitExpValue([NotNull] YarnSpinnerParser.ExpValueContext context)
        {
            // An expression containing a value has the same type as the value
            // it contains.
            context.Type = context.value()?.Type ?? Types.Error;
        }

        public override void ExitIf_clause([NotNull] YarnSpinnerParser.If_clauseContext context)
        {
            // The condition for an if statement must be a boolean
            IType ifExpressionType = context.expression().Type;

            this.AddEqualityConstraint(ifExpressionType, Types.Boolean, context.expression(), s => $"if statement's expression must be a {Types.Boolean}, not a {ifExpressionType.Substitute(s)}");
            base.ExitIf_clause(context);
        }

        public override void ExitElse_if_clause([NotNull] YarnSpinnerParser.Else_if_clauseContext context)
        {
            // The condition for an elseif statement must be a boolean
            var ifExpressionType = context.expression()?.Type ?? Types.Error;

            this.AddEqualityConstraint(ifExpressionType, Types.Boolean, context.expression(), s => $"else if statement's expression must be a {Types.Boolean}, not a {ifExpressionType.Substitute(s)}");
            base.ExitElse_if_clause(context);
        }

        public override void ExitSet_statement([NotNull] YarnSpinnerParser.Set_statementContext context)
        {
            // The type of the expression must be convertible to the type of the
            // variable
            IType variableType = context.variable()?.Type ?? Types.Error;
            IType expressionType = context.expression()?.Type ?? Types.Error;
            string variableName = context.variable()?.GetText() ?? "<unknown>";

            this.AddConvertibleConstraint(expressionType, variableType, context, s => $"{variableName} ({variableType.Substitute(s)}) cannot be assigned a {expressionType.Substitute(s)}");
            base.ExitSet_statement(context);
        }

        public override void ExitValueFunc([NotNull] YarnSpinnerParser.ValueFuncContext context)
        {
            // ValueFunc is just a wrapper around a function call, so it just
            // uses the same type variable
            context.Type = context.function_call()?.Type ?? Types.Error;
            base.ExitValueFunc(context);
        }

        public override void ExitFunction_call([NotNull] YarnSpinnerParser.Function_callContext context)
        {
            // If we already have a declaration for this function, then use
            // information from that
            string? functionName = context.FUNC_ID()?.GetText();
            var functionDecl = this.GetKnownDeclaration(functionName);

            FunctionType functionType;

            if (functionDecl == null)
            {
                // We don't know about this function. We'll need to create a new
                // declaration.

                TypeVariable returnType = this.GenerateTypeVariable($"return from {functionName}", context);

                functionType = new FunctionType(returnType);

                int count = 1;
                foreach (var expression in context.expression())
                {
                    var parameterType = this.GenerateTypeVariable($"{functionName} param {count}", context);
                    functionType.AddParameter(parameterType);

                    count++;
                }

                functionDecl = new Declaration
                {
                    Name = functionName ?? "<unknown>",
                    IsImplicit = true,
                    SourceFileName = this.sourceFileName,
                    Range = Utility.GetRange(context),
                    Type = functionType,
                };

                this.AddDeclaration(functionDecl);
            }
            else
            {
                functionType = (FunctionType)functionDecl.Type;
            }

            context.Type = this.GenerateTypeVariable(null, context);

            int actualParameters = context.expression()?.Count() ?? 0;
            int expectedParameters = functionType.Parameters.Count();

            bool functionIsVariadic = functionType.VariadicParameterType != null;

            // Check to see if we have the expected number of parameters
            if (actualParameters != expectedParameters && !functionIsVariadic)
            {
                // We don't! Create a diagnostic message and make this
                // expression be the Error type.

                string message;

                var expectedEnglishPlural = expectedParameters != 1;
                var actualEnglishPlural = actualParameters != 1;

                // If the function declaration is implicit, give a message here
                // that hedges a bit - we don't know if _this_ call is the
                // incorrect one.
                if (functionDecl.IsImplicit)
                {
                    message = $"{functionName} was called elsewhere with {expectedParameters} {(expectedEnglishPlural ? "parameters" : "parameter")}, but is called with {actualParameters} {(actualEnglishPlural ? "parameters" : "parameter")} here";
                }
                else
                {
                    message = $"{functionName} expects {expectedParameters} {(expectedEnglishPlural ? "parameters" : "parameter")}, not {actualParameters}";
                }

                this.diagnostics.Add(new Diagnostic(this.sourceFileName, context, message));
            }

            for (int paramID = 0; paramID < actualParameters; paramID++)
            {
                var parameterExpression = context.expression()[paramID];
                try
                {
                    var expectedType = functionType.GetParameterAt(paramID); //functionType.Parameters[paramID];
                    var actualType = parameterExpression.Type;

                    this.AddConvertibleConstraint(actualType, expectedType, parameterExpression, s => $"{parameterExpression.GetText()} ({parameterExpression.Type.Substitute(s)}) is not convertible to {expectedType.Substitute(s)}");
                }
                catch (ArgumentOutOfRangeException)
                {
                    this.diagnostics.Add(new Diagnostic(this.sourceFileName, parameterExpression, "Unexpected parameter in call to function " + functionName ?? "<unknown>"));
                }
            }

            // The type of this function call is the return type of the function
            this.AddEqualityConstraint(context.Type, functionType.ReturnType, context, s => $"Call to {functionDecl.Name} returns {functionType.ReturnType}, not {context.Type}");

            base.ExitFunction_call(context);
        }

        public override void ExitLineCondition([NotNull] YarnSpinnerParser.LineConditionContext context)
        {
            if (context.expression() != null)
            {
                this.AddEqualityConstraint(context.expression().Type, Types.Boolean, context, s => $"line condition's expression must be a {Types.Boolean}, not a {context.expression().Type.Substitute(s)}");
            }
            base.ExitLineCondition(context);
        }

        public override void ExitLineOnceCondition([NotNull] YarnSpinnerParser.LineOnceConditionContext context)
        {
            if (context.expression() != null)
            {
                this.AddEqualityConstraint(context.expression().Type, Types.Boolean, context, s => $"line condition's expression must be a {Types.Boolean}, not a {context.expression().Type.Substitute(s)}");
            }

            var lineStatement = FindParent<YarnSpinnerParser.Line_statementContext>(context);

            if (lineStatement != null)
            {
                var onceVariableName = Compiler.GetContentViewedVariableName(
                    lineStatement.LineID ?? throw new InvalidOperationException("Internal error: can't generate a 'once' variable for line, because it has no line ID")
                );


                RegisterOnceVariable(context, onceVariableName, $"'once' line condition for line ID {lineStatement.LineID}, in file {sourceFileName}, node {currentNodeName}, line {context.Start.Line.ToString(System.Globalization.CultureInfo.InvariantCulture)}");
            }

            base.ExitLineOnceCondition(context);
        }

        private static T? FindParent<T>(RuleContext start) where T : ParserRuleContext
        {
            var current = start;
            while (current != null)
            {
                if (typeof(T).IsAssignableFrom(current.GetType()))
                {
                    return (T)current;
                }
                current = current.Parent;
            }
            return null;
        }

        private void RegisterOnceVariable(ParserRuleContext context, string onceVariableName, string description)
        {
            var decl = GetKnownDeclaration(onceVariableName);
            if (decl == null)
            {
                decl = new Declaration
                {
                    Name = onceVariableName,
                    Type = Types.Boolean,
                    Description = description,
                    DefaultValue = false,
                    IsImplicit = true,
                };

                this.AddDeclaration(decl);
            }
            else
            {
                // If we're here, we've somehow generated the same 'once'
                // variable for more than one piece of content.
                this.AddDiagnostic(context, $"Internal error: redeclaration of existing 'once' variable {onceVariableName}");
            }
        }

        public override void ExitOnce_primary_clause([NotNull] YarnSpinnerParser.Once_primary_clauseContext context)
        {
            // If the once statement has an expression, it must be a boolean
            // expression
            if (context.expression() != null)
            {
                this.AddEqualityConstraint(context.expression().Type, Types.Boolean, context, s => $"line condition's expression must be a {Types.Boolean}, not a {context.expression().Type.Substitute(s)}");
            }

            // Generate a variable for tracking whether we have seen this
            // content before

            // Generate a relatively stable unique ID for this tag, based on
            // where it is in the overall compilation

            var description = $"'once' statement in file {sourceFileName}, node {currentNodeName}, line {context.Start.Line.ToString(System.Globalization.CultureInfo.InvariantCulture)}";

            var onceTag = CRC32.GetChecksumString(description);
            var onceVariableName = Compiler.GetContentViewedVariableName(onceTag);

            RegisterOnceVariable(context, onceVariableName, description);

            context.OnceVariableName = onceVariableName;

            base.ExitOnce_primary_clause(context);
        }

        public override void ExitJumpToExpression([NotNull] YarnSpinnerParser.JumpToExpressionContext context)
        {
            if (context.expression() != null)
            {
                // The type of the expression must be convertible to a string.
                this.AddConvertibleConstraint(context.expression()?.Type ?? Types.Error,
                    Types.String,
                    context,
                    s => $"jump statement's expression must be convertible to {Types.String}, but {context.expression().Type.Substitute(s)} is not");
            }

            base.ExitJumpToExpression(context);
        }

        public override void ExitEnum_statement([NotNull] YarnSpinnerParser.Enum_statementContext context)
        {
            // We've just finished walking an enum statement! We're almost ready
            // to add its declaration.

            if (context.exception != null)
            {
                // A parse exception exists in this context. Don't attempt to
                // create a type.
                return;
            }

            // First: are there any types with the same name as this?
            if (this.knownTypes.Any(t => t.Name == context.name.Text))
            {
                // There is! That's not allowed. Issue a diagnostic and return
                // without registering the new type.
                this.diagnostics.Add(new Diagnostic(this.sourceFileName, context, $"Cannot declare new enum {context.name.Text}: a type with this name already exists"));
                return;
            }

            // Get its description, if any
            var description = Compiler.GetDocumentComments(this.tokens, context, false);

            // Get the collection of case values that this enum can have.
            foreach (var caseStatement in context.enum_case_statement())
            {
                var caseDescription = Compiler.GetDocumentComments(this.tokens, caseStatement);

                caseStatement.Description = caseDescription;

                // Did the case statement have a raw value syntax node?
                if (caseStatement.rawValue == null)
                {
                    // No raw value in this case statement.
                    caseStatement.RawValue = null;
                }
                else
                {
                    // This case statement has a raw value. Parse it.
                    Value value = new LiteralValueVisitor(context, this.sourceFileName, this.diagnostics).Visit(caseStatement.rawValue);

                    caseStatement.RawValue = value;
                }
            }

            // Decide on the raw type of this enum.
            var allRawTypes = context
                .enum_case_statement()
                .Select(c => c.RawValue?.Type)
                .NotNull()
                .Distinct();

            IType rawType;

            if (allRawTypes.Count() == 0)
            {
                // No case had a raw type. Default the raw type to Number, and
                // set them all to be monotonically increasing values (0, 1, 2,
                // etc)
                rawType = Types.Number;

                int index = 0;
                foreach (var @case in context.enum_case_statement())
                {
                    @case.RawValue = new Value(Types.Number, index);
                    index += 1;
                }
            }
            else if (allRawTypes.Count() > 1)
            {
                // More than one raw value type is present. That's not allowed!

                // Issue a diagnostic and return without registering the new
                // type.
                this.diagnostics.Add(new Diagnostic(this.sourceFileName, context.name, $"Enum member raw values may only be of a single type (they can't be a combination of {string.Join(" and ", allRawTypes)})"));
                return;
            }
            else if (allRawTypes.Count() == 1)
            {
                // We only saw one raw value type.
                rawType = allRawTypes.Single();

                var permittedRawTypes = new TypeBase[]
                {
                    (TypeBase)Types.String,
                    (TypeBase)Types.Number,
                };

                var typeIsAllowed = false;
                foreach (var permittedType in permittedRawTypes)
                {
                    if (rawType is TypeBase literal)
                    {
                        if (literal.IsConvertibleTo(permittedType))
                        {
                            typeIsAllowed = true;
                            break;
                        }
                    }
                }

                if (typeIsAllowed == false)
                {
                    // The type is not one of our allowed ones! That's not
                    // allowed. Generate a diagnostic and return without
                    // registering the type.
                    this.diagnostics.Add(new Diagnostic(this.sourceFileName, context, $"Enum raw values must be {string.Join(" or ", (IEnumerable<TypeBase?>)permittedRawTypes)}, not {rawType}"));
                    return;
                }

                // Next: if one case has a raw value, they all need to.

                // Do we have any cases that are missing values?
                var casesMissingValues = context.enum_case_statement().Where(c => c.RawValue == null);

                if (casesMissingValues.Any())
                {
                    // Some cases don't have raw values. That's not allowed -
                    // either none of them have raw values, or they all do.

                    // Generate diagnostics for all cases that don't have a
                    // value and return without registering the type.
                    foreach (var @case in casesMissingValues)
                    {
                        this.diagnostics.Add(new Diagnostic(this.sourceFileName, @case, $"Enum case {@case.name.Text} must also have a raw value (if any cases have a value, then they all must have one)"));
                    }

                    return;
                }

                // Next: all cases must have a unique value.
                var valueGroups = context.enum_case_statement().GroupBy(c => c.RawValue?.InternalValue);

                var anyDuplicateValues = false;

                foreach (var group in valueGroups)
                {
                    if (group.Count() > 1)
                    {
                        // Two or more cases have the same name! That's not
                        // allowed.
                        anyDuplicateValues = true;
                        foreach (var duplicateCase in group)
                        {
                            this.diagnostics.Add(new Diagnostic(this.sourceFileName, duplicateCase, $"Enum case {@duplicateCase.name.Text} must have a unique raw value ({duplicateCase.RawValue?.InternalValue} is used by {group.Count() - 1} other case(s).)"));
                        }
                    }
                }

                if (anyDuplicateValues)
                {
                    // Return; we'll have already generated the appropriate
                    // diagnostics.
                    return;
                }

                // If the raw type is number, we require that all values be integers.
                if (rawType == Types.Number)
                {
                    foreach (var @case in context.enum_case_statement())
                    {
                        float number = Convert.ToSingle(@case.RawValue!.InternalValue);
                        if ((int)(number) != number)
                        {
                            // Not an integer!
                            this.diagnostics.Add(new Diagnostic(this.sourceFileName, context, $"Number raw values on enum cases must be integers"));
                        }
                    }
                }


            }
            else
            {
                throw new InvalidOperationException("Internal error");
            }

            // Last check: regardless of any raw values (or lack thereof), all
            // cases must have unique names.
            var nameGroups = context.enum_case_statement().GroupBy(c => c.name.Text);
            bool anyDuplicateNames = false;
            foreach (var group in nameGroups)
            {
                if (group.Count() > 1)
                {
                    // Two or more cases have the same name! That's not allowed.
                    anyDuplicateNames = true;

                    // Produce an error for the duplicates, skipping the first
                    // one
                    foreach (var duplicateCase in group.Skip(1))
                    {
                        this.diagnostics.Add(new Diagnostic(this.sourceFileName, duplicateCase, $"Enum case {@duplicateCase.name.Text} must have a unique name."));
                    }
                }
            }

            if (anyDuplicateNames)
            {
                // Return; we'll have already generated the appropriate
                // diagnostics.
                return;
            }

            // Create the new type.
            var newEnumType = new EnumType(context.name.Text, description ?? string.Empty, (TypeBase)rawType);

            // Register the cases for this enum.
            foreach (var @case in context.enum_case_statement())
            {
                newEnumType.AddMember(
                    @case.name.Text,
                    new ConstantTypeProperty(
                        rawType,
                        @case.RawValue?.InternalValue ?? 0,
                        @case.Description ?? string.Empty));
            }

            // Finally, register the type!
            this.knownTypes.Add(newEnumType);

            base.ExitEnum_statement(context);
        }

        public override void ExitOnce_statement([NotNull] YarnSpinnerParser.Once_statementContext context)
        {
            YarnSpinnerParser.ExpressionContext? expressionContext = context.once_primary_clause()?.expression();

            if (expressionContext != null)
            {
                // If this 'once' statement has an expression, that expression's
                // type must be boolean
                this.AddEqualityConstraint(expressionContext.Type, Types.Boolean, context, s => $"once statement's expression must be a {Types.Boolean}, not a {expressionContext.Type.Substitute(s)}");
            }

            base.ExitOnce_statement(context);
        }

        public override void ExitHeader_when_expression([NotNull] YarnSpinnerParser.Header_when_expressionContext context)
        {
            // A 'when' header contains either the keyword 'always' (indicating
            // that the content can always be selected), or a boolean value.
            var expression = context.expression();

            if (expression != null)
            {
                // If the header contains an expression, that expression's type
                // must be boolean
                this.AddEqualityConstraint(expression.Type, Types.Boolean, context, s => $"'when' header expressions must be a {Types.Boolean} or 'always', not a {expression.Type.Substitute(s)}");
            }

            if (context.once != null)
            {
                // The header contains a 'once' condition. Declare the variable
                // for tracking it.
                var parentNode = FindParent<YarnSpinnerParser.NodeContext>(context);

                if (parentNode != null && parentNode.NodeTitle != null)
                {
                    var title = parentNode.NodeTitle;
                    var onceVariable = Compiler.GetContentViewedVariableName(title);

                    RegisterOnceVariable(context, onceVariable, $"'once' node condition for {parentNode.NodeTitle}");
                }

            }
        }

        public override void ExitStatement([NotNull] YarnSpinnerParser.StatementContext context)
        {
            this.CancellationToken.ThrowIfCancellationRequested();

            try
            {
                if (this.typeEquations.Count == 0)
                {
                    // We have no type equations to solve, so there's nothing to
                    // do.
                    return;
                }

                // We have type constraints to resolve.
                var knownTypes = this.knownTypes.Cast<TypeBase>().ToList();

                // Apply our current solution to the equations, and remove any
                // that are now tautological (e.g. 'T(a) == bool' becoming 'bool
                // == bool'). This might immediately knock out some equations,
                // reducing the amount of solving we need to do.
                this.typeEquations = ApplySolution(typeSolution, this.typeEquations).ToList();

                if (this.typeEquations.Count == 0)
                {
                    return;
                }

                // Run the solver on type equalities. (Doing this gets us useful
                // type information that guides other, more complex constraints
                // like convertability.)
                var equalities = this.typeEquations.OfType<TypeEqualityConstraint>();
                if (Solver.TrySolve(equalities, knownTypes, this.diagnostics, ref typeSolution) == false)
                {
                    foreach (var constraint in equalities)
                    {
                        failingTypeConstraints.Add(constraint);
                    }
                }

                // Run the solver on the remainder of the constraints.
                var otherConstraints = this.typeEquations.Except(equalities);
                if (Solver.TrySolve(otherConstraints, knownTypes, this.diagnostics, ref typeSolution) == false)
                {
                    foreach (var constraint in equalities)
                    {
                        failingTypeConstraints.Add(constraint);
                    }
                }

                // Apply the solution to our equations, and eliminate any that
                // are now tautological. (If our program's type definitions are
                // self-contained, then this will likely result in eliminating
                // ALL outstanding equations.)

                this.typeEquations = ApplySolution(TypeSolution, this.typeEquations).ToList();
            }
            finally
            {
                base.ExitStatement(context);
            }
        }

        internal static IEnumerable<TypeConstraint> ApplySolution(Substitution solution, IEnumerable<TypeConstraint> incomingConstraints)
        {
            return incomingConstraints
                .Select(e => e.ApplySubstitution(solution))
                .WithoutTautologies()
                .ToList();
        }

        public override void ExitDialogue([NotNull] YarnSpinnerParser.DialogueContext context)
        {
            if (typeEquations.Count > 0)
            {
                // We've reached the end of the file, but we still have
                // unresolved type equations, indicating that we didn't manage
                // to fully resolve this type system. Add them as a potential
                // failure.
                foreach (var constraint in typeEquations)
                {
                    failingTypeConstraints.Add(constraint);
                }
            }
            base.ExitDialogue(context);
        }

        /// <summary>
        /// Given a collection of Declaration objects that have fully-resolved
        /// types, determines the appropriate value to use as this declaration's
        /// initial value.
        /// </summary>
        /// <param name="declarations">The list of declarations to
        /// update.</param>
        /// <param name="diagnostics">The list of diagnostics to add to.</param>
        public static void ResolveInitialValues(ref List<Declaration> declarations, ref List<Diagnostic> diagnostics)
        {
            if (declarations == null)
            {
                throw new ArgumentNullException(nameof(declarations));
            }

            if (diagnostics == null)
            {
                throw new ArgumentNullException(nameof(diagnostics));
            }

            foreach (var decl in declarations)
            {
                if (decl.InitialValueParserContext is YarnSpinnerParser.ExpValueContext valueContext
                    && !(valueContext.value() is YarnSpinnerParser.ValueFuncContext)
                    && !(valueContext.value() is YarnSpinnerParser.ValueVarContext))
                {
                    // If the value of a declaration is a plain value (and not a
                    // more complex expression AND not a function call AND not a
                    // variable), then the declaration is of a stored variable
                    // with an initial value.
                    if (valueContext.value() is YarnSpinnerParser.ILiteralContext)
                    {
                        // The initial value was a literal. Parse it and turn it
                        // into a value we can store.
                        var literalVisitor = new LiteralValueVisitor(valueContext.value(), decl.SourceFileName, diagnostics);

                        var value = literalVisitor.Visit(valueContext.value());

                        decl.DefaultValue = value.InternalValue;
                    }
                    else if (valueContext.value() is YarnSpinnerParser.ValueTypeMemberReferenceContext memberReference)
                    {
                        // The initial value was a reference to a member of a
                        // type. Get that member's value.
                        var memberName = memberReference.typeMemberReference().memberName.Text;
                        var type = memberReference.Type;

                        if (!(type is TypeBase actualType))
                        {
                            diagnostics.Add(new Diagnostic(decl.SourceFileName, valueContext.value(), $"Can't determine the type of {valueContext.value().GetTextWithWhitespace()}"));
                            continue;
                        }

                        if (!actualType.TypeMembers.TryGetValue(memberName, out var member))
                        {
                            diagnostics.Add(new Diagnostic(decl.SourceFileName, valueContext.value(), $"{actualType.Name} doesn't have a member named {memberName}"));
                            continue;
                        }

                        if (!(member is ConstantTypeProperty property))
                        {
                            diagnostics.Add(new Diagnostic(decl.SourceFileName, valueContext.value(), $"{actualType.Name}.{memberName} is not a constant property"));
                            continue;
                        }

                        decl.DefaultValue = property.Value;
                    }
                }
                else if (decl.InitialValueParserContext is YarnSpinnerParser.ExpressionContext)
                {
                    // The value of the expression is runtime-evaluated. This
                    // declaration is for an inline-expanded expression (a
                    // 'smart variable'). No default value is provided; instead,
                    // this variable is inline-expanded when it's encountered
                    // during code generation.
                    decl.IsInlineExpansion = true;
                }
            }

            // Now that we've identified a value for every declaration, we need
            // to check if there are any dependency loops between smart
            // declarations.
            var smartVariableDeclarations = declarations.Where(d => d.IsInlineExpansion);
            var allDeclsDict = declarations.Where(d => d.Name != null).ToDictionary(d => d.Name, d => d);

            // Calculate the dependencies for each smart variable, catching any
            // loops
            foreach (var smartVariableDecl in smartVariableDeclarations)
            {
                var dependencies = GetDependenciesForVariable(smartVariableDecl, allDeclsDict, out var error);
                if (error != null)
                {
                    diagnostics.Add(error);
                    continue;
                }

                smartVariableDecl.Dependencies = dependencies;
                foreach (var dependency in dependencies)
                {
                    dependency.Dependents = (dependency.Dependents ?? Enumerable.Empty<Declaration>()).Append(smartVariableDecl);
                }
            }

            // Make all dependency lists distinct
            foreach (var decl in declarations)
            {
                decl.Dependencies = decl.Dependencies?.Distinct() ?? Enumerable.Empty<Declaration>();
                decl.Dependents = decl.Dependents?.Distinct() ?? Enumerable.Empty<Declaration>();
            }
        }

        internal static IEnumerable<Declaration> GetDependenciesForVariable(Declaration startDecl, IDictionary<string, Declaration> decls, out Diagnostic? loopError)
        {
            var dependencies = new HashSet<Declaration>();
            var searchStack = new Stack<(ParserRuleContext ctx, int level)>();

            if (startDecl.InitialValueParserContext == null)
            {
                // This declaration has no initial value parse context. It
                // therefore doesn't reference any other variables.
                loopError = null;
                return dependencies;
            }

            var seenDecls = new HashSet<(Declaration decl, int level)>() {
                (startDecl, 0)
            };

            searchStack.Push((startDecl.InitialValueParserContext, 0));

            while (searchStack.Count > 0)
            {
                var (item, level) = searchStack.Pop();

                if (item is YarnSpinnerParser.VariableContext variable)
                {
                    // This item is a variable. Find its declaration.
                    string variableName = variable.VAR_ID().GetText();
                    if (decls.TryGetValue(variableName, out var dependencyDecl))
                    {
                        // Is this decl a smart variable? (Only smart variables
                        // can have dependencies, so they're the only ones we
                        // need to care about when figuring out dependency
                        // cycles.)
                        if (dependencyDecl.IsInlineExpansion == false)
                        {
                            // It's a regular stored variable, so add it and
                            // move on.
                            dependencies.Add(dependencyDecl);
                            continue;
                        }

                        // Have we seen this declaration at an earlier level of recusion?
                        if (seenDecls.Any(i => i.decl == dependencyDecl && i.level != level))
                        {
                            // We've found a dependency loop!
                            loopError = new Diagnostic(startDecl.SourceFileName, variable, $"Smart variables cannot contain reference loops (referencing {variable.GetTextWithWhitespace()} here creates a loop for the smart variable {startDecl.Name})");
                            return Enumerable.Empty<Declaration>();
                        }

                        seenDecls.Add((dependencyDecl, level));

                        // Add this variable to the set of dependencies of
                        // startDecl.
                        dependencies.Add(dependencyDecl);

                        if (dependencyDecl.InitialValueParserContext == null)
                        {
                            throw new InvalidOperationException($"Internal error: {dependencyDecl} was marked as being a smart variable, but it has no {nameof(dependencyDecl.InitialValueParserContext)}");
                        }

                        // Add this smart variable's definition to our search.
                        searchStack.Push((dependencyDecl.InitialValueParserContext, level + 1));
                    }
                    else
                    {
                        // We couldn't find a declaration for this variable.
                        throw new InvalidOperationException($"Internal error: found undeclared variable {variableName} while finding dependencies of {startDecl.Name}");
                    }
                }

                // Add all children to the search.
                var childContexts = item.children
                    .Where(tree => tree.Payload is ParserRuleContext)
                    .Select(tree => tree.Payload as ParserRuleContext)
                    .NotNull();

                foreach (var child in childContexts)
                {
                    searchStack.Push((child, level + 1));
                }
            }

            loopError = null;
            return dependencies;
        }
    }

    /// <summary>
    /// Provides methods for walking a parse tree.
    /// </summary>
    internal static class ParseTreeWalker
    {
        /// <summary>
        /// Walks a parse tree, starting at <paramref name="startContext"/>, and
        /// calls <paramref name="handler"/> for each <see
        /// cref="ParserRuleContext"/> it encounters.
        /// </summary>
        /// <param name="startContext">The parser rule context to begin walking
        /// from.</param>
        /// <param name="handler">The delegate to call for each parser rule
        /// context encountered.</param>
        public static void WalkTree(ParserRuleContext startContext, Action<ParserRuleContext> handler)
        {
            WalkTree<ParserRuleContext>(startContext, handler);
        }

        /// <summary>
        /// Walks a parse tree, starting at <paramref name="startContext"/>, and
        /// calls <paramref name="handler"/> for each <typeparamref
        /// name="TContext"/> it encounters.
        /// </summary>
        /// <typeparam name="TContext">The type of parser rule context to call
        /// <paramref name="handler"/> for.</typeparam>
        /// <param name="startContext">The parser rule context to begin walking
        /// from.</param>
        /// <param name="handler">The delegate to call for each parser rule
        /// context encountered.</param>
        public static void WalkTree<TContext>(ParserRuleContext startContext, Action<TContext> handler)
            where TContext : ParserRuleContext
        {
            var searchStack = new Stack<ParserRuleContext>();
            searchStack.Push(startContext);
            while (searchStack.Count > 0)
            {
                var item = searchStack.Pop();

                if (item is TContext context)
                {
                    handler(context);
                }

                if (item.children != null)
                {
                    var childContexts = item.children
                        .Where(tree => tree.Payload is ParserRuleContext)
                        .Select(tree => tree.Payload as ParserRuleContext)
                        .NotNull();

                    foreach (var child in childContexts)
                    {
                        searchStack.Push(child);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Contains properties common to all parse nodes that have a type
    /// associated with them.
    /// </summary>
    public interface ITypedContext
    {
        /// <summary>
        /// Gets or sets the type of this parse node.
        /// </summary>
        IType Type { get; set; }
    }

    public partial class YarnSpinnerParser
    {
        /// <summary>
        /// Adds type properties to <see cref="ExpressionContext"/>.
        /// </summary>
        public partial class ExpressionContext : ITypedContext
        {
            /// <inheritdoc/>
            public IType Type { get; set; } = Types.Error;
        }

        /// <summary>
        /// Adds type properties to <see cref="ValueContext"/>.
        /// </summary>
        public partial class ValueContext : ITypedContext
        {
            /// <inheritdoc/>
            public IType Type { get; set; } = Types.Error;
        }

        /// <summary>
        /// Adds type properties to <see cref="VariableContext"/>.
        /// </summary>
        public partial class VariableContext : ITypedContext
        {
            /// <inheritdoc/>
            public IType Type { get; set; } = Types.Error;
        }

        /// <summary>
        /// Adds type properties to <see cref="Function_callContext"/>.
        /// </summary>
        public partial class Function_callContext : ITypedContext
        {
            /// <inheritdoc/>
            public IType Type { get; set; } = Types.Error;
        }

        /// <summary>
        /// Adds enum case type information to <see
        /// cref="Enum_case_statementContext"/>.
        /// </summary>
        public partial class Enum_case_statementContext : ParserRuleContext
        {

            /// <summary>
            /// Gets or sets the 'raw value' of this enum case, which is the
            /// underlying value that this enum represents.
            /// </summary>
            internal Yarn.Value? RawValue { get; set; }

            /// <summary>
            /// Gets or sets the descriptive text for this enum case.
            /// </summary>
            internal string? Description { get; set; }
        }

        /// <summary>
        /// Adds 'once' variable information to <see
        /// cref="Once_primary_clauseContext"/>.
        /// </summary>
        public partial class Once_primary_clauseContext : ParserRuleContext
        {
            /// <summary>
            /// The name of the variable that tracks whether once statement
            /// primary clause has been seen before or not.
            /// </summary>
            internal string? OnceVariableName { get; set; }
        }
    }
}
